\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{array}
\usepackage{float}

% Define a basic Verilog language for listings.
\lstdefinelanguage{Verilog}{
    keywords={module, input, output, wire, assign, endmodule, always, posedge, if, else, begin, end, reg},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]"
}

% Define a style for Verilog code.
\lstdefinestyle{verilogstyle}{
    language=Verilog,
    basicstyle=\ttfamily\small,
    commentstyle=\color{gray}\itshape,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    breaklines=true,
    showstringspaces=false,
    frame=single
}

\title{Report on Verilog Designs: Priority Encoder, Up Counter, and Even Parity Generator}
\author{EE24BTECH11024}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
This report explains three digital design implementations written in Verilog. The designs include:
\begin{enumerate}
    \item A 4-to-2 Priority Encoder.
    \item A 4-bit Up Counter with Enable and Asynchronous Reset.
    \item An 8-bit Even Parity Generator.
\end{enumerate}
Each section discusses the functionality, design choices, and code implementation details that fulfill the given specifications. Truth tables and a formal proof are included to explain the logic.

\section{4-to-2 Priority Encoder}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Inputs:} \(\mathtt{in[3:0]}\) --- A 4-bit input signal.
    \item \textbf{Outputs:}
    \begin{itemize}
        \item \(\mathtt{out[1:0]}\) --- A 2-bit binary output indicating the position of the highest-priority input that is high.
        \item \(\mathtt{valid}\) --- A 1-bit output that is set to 1 if any input bit is high, otherwise 0.
    \end{itemize}
    \item \textbf{Priority Order:} \(\mathtt{in[3] > in[2] > in[1] > in[0]}\)
\end{itemize}

\subsection{Code Explanation}
The Verilog module uses continuous assignments with reduction and logical operators to implement the priority encoder.

\begin{lstlisting}[style=verilogstyle, caption={4-to-2 Priority Encoder}]
module top_module(input wire [3:0] in, 
                  output wire [1:0] out, 
                  output valid);
    // Assert valid if any input bit is high.
    assign valid = (|in[3:0]);
    
    // out[1] is high if either in[3] or in[2] is high.
    assign out[1] = in[3] | in[2];
    
    // out[0] is high if in[3] is high, or if in[1] is high while in[2] is low.
    assign out[0] = in[3] | ((~in[2]) & in[1]);
endmodule
\end{lstlisting}

\subsection{Truth Table}

\begin{center}
\begin{tabular}{|c|c|c|c||c|c|c|}
\hline
\(in_3\) & \(in_2\) & \(in_1\) & \(in_0\) & valid & \(out_1\) & \(out_0\) \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 1 & 0 & 0 \\
0 & 0 & 1 & x & 1 & 0 & 1 \\
0 & 1 & x & x & 1 & 1 & 0 \\
1 & x & x & x & 1 & 1 & 1 \\
\hline
\end{tabular}
\end{center}

\subsection{Discussion}
\begin{itemize}
    \item The \texttt{valid} signal is generated by a reduction OR operator which produces a 1 if any input bit is high.
    \item The logic ensures priority is maintained: higher-indexed inputs dominate the output.
\end{itemize}

\section{4-bit Up Counter with Enable and Asynchronous Reset}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Inputs:}
    \begin{itemize}
        \item \(\mathtt{clk}\) --- Clock signal.
        \item \(\mathtt{reset}\) --- Asynchronous reset signal (active high).
        \item \(\mathtt{enable}\) --- Control signal to enable counting.
    \end{itemize}
    \item \textbf{Output:} \(\mathtt{count[3:0]}\) --- A 4-bit output representing the current count value.
\end{itemize}

\subsection{Code Explanation}
The counter is implemented by cascading T flip-flops. Each T flip-flop toggles when its T input is 1. The toggle inputs are defined as:
\[
\begin{aligned}
T_0 &= \texttt{enable} \\
T_1 &= \texttt{enable} \land Q_0 \\
T_2 &= \texttt{enable} \land Q_0 \land Q_1 \\
T_3 &= \texttt{enable} \land Q_0 \land Q_1 \land Q_2 \\
\end{aligned}
\]

\begin{lstlisting}[style=verilogstyle, caption={4-bit Up Counter}]
module top_module(input clk, input reset, input enable, output [3:0] count);

    wire t0, t1, t2, t3;

    assign t0 = enable;
    assign t1 = enable & count[0];
    assign t2 = enable & count[0] & count[1];
    assign t3 = enable & count[0] & count[1] & count[2];   
    
    Tflipflop ff0(clk, t0, reset, count[0]);
    Tflipflop ff1(clk, t1, reset, count[1]);
    Tflipflop ff2(clk, t2, reset, count[2]);
    Tflipflop ff3(clk, t3, reset, count[3]);

endmodule

module Tflipflop(input clk, input T, input reset, output reg Q);
    always @(posedge clk, posedge reset) begin
        if (reset == 1)
            Q <= 1'b0;
        else if (T == 1)
            Q <= ~Q;
    end
endmodule
\end{lstlisting}

\subsection{Truth Table (Toggle Conditions and Next State)}
\begin{center}
\includegraphics[width=\textwidth]{toggle_truth_table.png}
\end{center}

\subsection{Discussion}
\begin{itemize}
    \item Each flip-flop toggles based on enable and lower-order bits, creating a ripple effect.
    \item This is a modular and scalable way to design counters using T flip-flops.
\end{itemize}

\section{8-bit Even Parity Generator}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Input:} \(\mathtt{data[7:0]}\) (aka \(\mathtt{in[7:0]}\)) --- An 8-bit input vector.
    \item \textbf{Output:} \(\mathtt{parity}\) --- A single-bit output representing the even parity bit.
\end{itemize}

\subsection{Code Explanation}
The parity generator uses the Verilog reduction XOR operator to compute the even parity bit.

\begin{lstlisting}[style=verilogstyle, caption={8-bit Even Parity Generator}]
module top_module(input wire [7:0] in, output out);
    assign out = ^in;
endmodule
\end{lstlisting}

\subsection{Proof that XORing All Bits Generates Even Parity}
The XOR operator (\(\oplus\)) satisfies these properties:
\begin{itemize}
    \item \textbf{Associativity:} \((a \oplus b) \oplus c = a \oplus (b \oplus c)\)
    \item \textbf{Commutativity:} \(a \oplus b = b \oplus a\)
    \item \textbf{Identity:} \(a \oplus 0 = a\)
    \item \textbf{Self-Inverse:} \(a \oplus a = 0\)
\end{itemize}

Let:
\[
p = b_0 \oplus b_1 \oplus \cdots \oplus b_7
\]
Then:
\begin{itemize}
    \item If there are an even number of 1's, they cancel out pairwise, and \(p = 0\)
    \item If there's an odd number of 1's, one remains unpaired, and \(p = 1\)
\end{itemize}

\textbf{Proof by Induction:}
\begin{enumerate}
    \item \textbf{Base Case:} One bit \(b_0\): parity is just \(b_0\)
    \item \textbf{Inductive Step:} Assume correct for \(n\) bits. Adding \(b_n\):
    \[
    p_{n+1} = p_n \oplus b_n
    \]
    This flips the parity if \(b_n = 1\), otherwise keeps it the same.
\end{enumerate}
Hence, \(^in\) computes the parity bit such that appending it to the data gives an even number of 1's.

\section{Conclusion}
This report detailed three Verilog modules:
\begin{enumerate}
    \item \textbf{Priority Encoder:} Implements input-priority logic using bitwise operators.
    \item \textbf{Up Counter:} Uses T flip-flops to increment state based on enable.
    \item \textbf{Parity Generator:} Uses XOR reduction to compute even parity.
\end{enumerate}
Each demonstrates effective modular and logical design techniques suitable for digital system development.

\end{document}
