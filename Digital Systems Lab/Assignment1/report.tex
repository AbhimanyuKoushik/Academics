\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{array}
\usepackage{float}
\usepackage{karnaugh-map} % for generating Karnaugh maps

% Define a basic Verilog language for listings.
\lstdefinelanguage{Verilog}{
    keywords={module, input, output, wire, assign, endmodule, always, posedge, if, else, begin, end, reg},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]"
}

% Define a style for Verilog code.
\lstdefinestyle{verilogstyle}{
    language=Verilog,
    basicstyle=\ttfamily\small,
    commentstyle=\color{gray}\itshape,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    breaklines=true,
    showstringspaces=false,
    frame=single
}

\title{Report on Verilog Designs: Priority Encoder, Up Counter, and Even Parity Generator}
\author{EE24BTECH11024}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
This report explains three digital design implementations written in Verilog. The designs include:
\begin{enumerate}
    \item A 4-to-2 Priority Encoder.
    \item A 4-bit Up Counter with Enable and Asynchronous Reset.
    \item An 8-bit Even Parity Generator.
\end{enumerate}
Each section discusses the functionality, design choices, and code implementation details that fulfill the given specifications. In addition, truth tables and Karnaugh maps are included to illustrate the underlying logic, and a formal proof is provided for the parity generator.

\section{4-to-2 Priority Encoder}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Inputs:} \({in[3:0]}\) --- A 4-bit input signal.
    \item \textbf{Outputs:}
    \begin{itemize}
        \item \({out[1:0]}\) --- A 2-bit binary output indicating the position of the highest-priority input that is high.
        \item \({valid}\) --- A 1-bit output that is set to 1 if any input bit is high, otherwise 0.
    \end{itemize}
    \item \textbf{Priority Order:} \({in[3] > in[2] > in[1] > in[0]}\)
\end{itemize}

\subsection{Code Explanation}
The Verilog module uses continuous assignments with reduction and logical operators to implement the priority encoder.

\begin{lstlisting}[style=verilogstyle, caption={4-to-2 Priority Encoder}]
module top_module(input wire [3:0] in, output wire [1:0] out, output valid);
    assign valid = (|in[3:0]);
    assign out[0] = (in[3] | ((~in[2]) & in[1]));
    assign out[1] = in[3] | in[2];
endmodule
\end{lstlisting}

\subsection{Truth Table}
The following truth table summarizes the operation of the encoder. (Here, “x” denotes a don't-care condition.)

\bigskip

\noindent \textbf{Table 1: Truth Table for the 4-to-2 Priority Encoder}

\bigskip

\begin{center}
\begin{tabular}{|c|c|c|c||c|c|c|}
\hline
\(in_3\) & \(in_2\) & \(in_1\) & \(in_0\) & valid & \(out_1\) & \(out_0\) \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
0 & 0 & 0 & 1 & 1 & 0 & 0 \\
\hline
0 & 0 & 1 & x & 1 & 0 & 1 \\
\hline
0 & 1 & x & x & 1 & 1 & 0 \\
\hline
1 & x & x & x & 1 & 1 & 1 \\
\hline
\end{tabular}
\end{center}

\subsection{Karnaugh Maps}

\subsubsection{Karnaugh Map for \({out[1]}\)}
For \({out[1]} = in[3] + in[2]\), the output is 1 whenever the upper two bits are not both 0. In our 4-variable Karnaugh map (with columns for \(in_3\,in_2\) and rows for \(in_1\,in_0\)), the minterms for which \({out[1]}=1\) correspond to indices 4 through 15.
\bigskip

\begin{center}
    \begin{karnaugh-map}[4][4][1][$in_2\,in_3$][$in_0\,in_1$]
    \manualterms{X,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1}
    \implicant{1}{11}
    \implicant{3}{10}
    \end{karnaugh-map}
\end{center}

\bigskip

\subsubsection{Karnaugh Map for \({out[0]}\)}
For \({out[0]} = in[3] + ((~ in[2]) \cdot in[1])\), the output is 1 when \(in[3]=1\) (minterms 8 through 15) or when \(in[3]=0\), \(in[2]=0\), and \(in[1]=1\) (minterms 2 and 3).

\bigskip
\begin{center}
\begin{karnaugh-map}[4][4][1][$in_2\,in_3$][$in_0\,in_1$]
\manualterms{X,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1}
\implicant{1}{11}
\implicant{4}{13}
\end{karnaugh-map}
\end{center}

\subsection{Discussion}
\begin{itemize}
    \item The \texttt{valid} signal is generated by a reduction OR operator which produces a 1 if any input bit is high.
    \item The Karnaugh maps illustrate how the functions for \({out[0]}\) and \({out[1]}\) are derived from the inputs, obeying the priority: if \(in[3]=1\) the outputs are \(11\); if only \(in[2]=1\) then \(10\); and so on.
\end{itemize}

\section{4-bit Up Counter with Enable and Asynchronous Reset}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Inputs:}
    \begin{itemize}
        \item \({clk}\) --- Clock signal.
        \item \({reset}\) --- Asynchronous reset signal (active high).
        \item \({enable}\) --- Control signal to enable counting.
    \end{itemize}
    \item \textbf{Output:} \({count[3:0]}\) --- A 4-bit output representing the current count value.
\end{itemize}

\subsection{Truth Table (Toggle Conditions and Next State)}
The following truth table (written in a style similar to the provided example) shows the present state, the toggle conditions for each flip-flop, and the resulting next state when \({enable}=1\).

\bigskip

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c||c|c|c|c||c|c|c|c|}
\hline
\multicolumn{4}{|c||}{Present State} & \multicolumn{4}{c||}{T Flip-Flops} & \multicolumn{4}{c|}{Next State} \\
\hline
\(Q_3\) & \(Q_2\) & \(Q_1\) & \(Q_0\) & \(T_3\) & \(T_2\) & \(T_1\) & \(T_0\) & \(Q_3'\) & \(Q_2'\) & \(Q_1'\) & \(Q_0'\) \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\
\hline
0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 \\
\hline
0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 \\
\hline
0 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 1 & 0 & 0 \\
\hline
0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 \\
\hline
0 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 & 0 \\
\hline
0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 \\
\hline
0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
\hline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \\
\hline
1 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 0 \\
\hline
1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 & 1 \\
\hline
1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
\hline
1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 \\
\hline
1 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
\hline
1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
\hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\
\hline
\end{tabular}
\caption{State table for the 4-bit Up Counter with Enable (\({enable}=1\)).}
\end{table}

\subsection{Code Explanation}
The counter is implemented by cascading T flip-flops. Each T flip-flop toggles when its T input is 1. The toggle inputs are defined (assuming \({enable}=1\)) as follows:
\[
\begin{aligned}
T_0 &= \texttt{enable} \\
T_1 &= \texttt{enable} \cdot Q_0 \\
T_2 &= \texttt{enable} \cdot Q_0 \cdot Q_1 \\
T_3 &= \texttt{enable} \cdot Q_0 \cdot Q_1 \cdot Q_2 \\
\end{aligned}
\]
Thus, the next state is the present state incremented by one modulo 16.

\begin{lstlisting}[style=verilogstyle, caption={4-bit Up Counter}]
module top_module(input clk, input reset, input enable, output [3:0] count);

    wire t0, t1, t2, t3;

    assign t0 = enable;
    assign t1 = enable & count[0];
    assign t2 = enable & count[0] & count[1];
    assign t3 = enable & count[0] & count[1] & count[2];   
    
    Tflipflop ff0(clk, t0, reset, count[0]);
    Tflipflop ff1(clk, t1, reset, count[1]);
    Tflipflop ff2(clk, t2, reset, count[2]);
    Tflipflop ff3(clk, t3, reset, count[3]);

endmodule

module Tflipflop(input clk, input T, input reset, output reg Q);

    always @(posedge clk, posedge reset) begin
        if (reset == 1) begin
            Q <= 1'b0;
        end
        else begin
            if (T == 1) begin
                Q <= ~Q;
            end
        end
    end

endmodule
\end{lstlisting}

\subsection{Discussion}
\begin{itemize}
    \item Each row shows how the present state and the corresponding toggle conditions determine the next state.
    \item For a standard binary counter, the next state is simply the present state plus one modulo 16.
\end{itemize}

\section{8-bit Even Parity Generator}

\subsection{Specifications}
\begin{itemize}
    \item \textbf{Input:} \({data[7:0]}\) (labeled as \({in[7:0]}\)) --- An 8-bit input vector.
    \item \textbf{Output:} \({parity}\) --- A single-bit output representing the even parity bit.
\end{itemize}

\subsection{Code Explanation}
The parity generator uses the Verilog reduction XOR operator to compute the even parity bit.

\begin{lstlisting}[style=verilogstyle, caption={8-bit Even Parity Generator}]
module top_module(input wire [7:0] in, output out);
    assign out = ^in;
endmodule
\end{lstlisting}

\subsection{Proof that XORing All Bits Generates Even Parity}
The key idea behind using the XOR operator (\(\oplus\)) to generate the even parity bit relies on its properties:
\begin{itemize}
    \item \textbf{Associativity:} \((a \oplus b) \oplus c = a \oplus (b \oplus c)\).
    \item \textbf{Commutativity:} \(a \oplus b = b \oplus a\).
    \item \textbf{Identity:} \(a \oplus 0 = a\).
    \item \textbf{Self-Inverse:} \(a \oplus a = 0\).
\end{itemize}
When we compute
\[
p = b_0 \oplus b_1 \oplus \cdots \oplus b_7,
\]
this is equivalent to summing the bits modulo 2:
\[
p = \sum_{i=0}^{7} b_i \pmod{2}.
\]
\begin{itemize}
    \item If there is an even number of 1's, the pairs of 1's cancel each other (\(1 \oplus 1 = 0\)) and thus \(p = 0\).
    \item If there is an odd number of 1's, one unpaired 1 remains, yielding \(p = 1\).
\end{itemize}

\textbf{Proof by Induction:}
\begin{enumerate}
    \item \textbf{Base Case:} For a single bit \(b_0\), \(p = b_0\). If \(b_0=0\), the parity is even (0); if \(b_0=1\), the parity is odd (1).
    \item \textbf{Inductive Step:} Assume that for \(n\) bits,
    \[
    p_n = b_0 \oplus b_1 \oplus \cdots \oplus b_{n-1},
    \]
    the result is 0 when there is an even number of 1's and 1 when odd. Adding the \((n+1)^\text{th}\) bit \(b_n\),
    \[
    p_{n+1} = p_n \oplus b_n.
    \]
    If \(b_n=0\), then \(p_{n+1}=p_n\) (parity unchanged); if \(b_n=1\), the parity flips, exactly as expected.
\end{enumerate}
Thus, the reduction XOR operation produces a parity bit \(p\) that is 0 if an even number of 1's exist and 1 if odd. When appended to the data, this ensures an even overall count of 1's.

\section{Conclusion}
This report detailed the design and implementation of three Verilog modules:
\begin{enumerate}
    \item The \textbf{4-to-2 Priority Encoder} uses combinational logic to determine the highest-priority active input. Its functionality is illustrated via a truth table and Karnaugh maps for \({out[0]}\) and \({out[1]}\).
    \item The \textbf{4-bit Up Counter} is implemented using cascaded T flip-flops with an enable and an asynchronous reset, as shown in the detailed state table.
    \item The \textbf{8-bit Even Parity Generator} employs the reduction XOR operator to compute the parity bit, with an illustrative 4-variable Karnaugh map and a formal induction proof.
\end{enumerate}
Each design meets its specifications with a modular approach, demonstrating key digital design techniques applicable to a wide range of electronic systems.

\end{document}